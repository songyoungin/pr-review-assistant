---
description: 관찰성 및 성능 관리 개요
alwaysApply: true
---

# 관찰성 및 성능 관리 개요

## 핵심 원칙
- **완전한 가시성**: 모든 시스템 동작과 성능을 실시간으로 모니터링
- **구조화된 로깅**: JSON 형식으로 일관된 로그 구조 유지
- **성능 우선**: PRD NFR-1 기준(평균 2분, 95p 5분) 준수
- **비용 효율성**: LLM 호출 비용과 리소스 사용량 최적화

# 로깅 전략

## 로그 구조 및 형식
- **JSON 로그**: 모든 로그는 구조화된 JSON 형식으로 기록
- **필수 필드**: timestamp, level, trace_id, agent, tool, message
- **선택 필드**: evidence_ref, user_id, correlation_id, duration_ms
- **로그 레벨**: DEBUG, INFO, WARNING, ERROR, CRITICAL

## 로그 카테고리별 분류
- **애플리케이션 로그**: 비즈니스 로직 실행 흐름
- **시스템 로그**: 인프라 및 리소스 상태
- **보안 로그**: 인증, 권한, 보안 이벤트
- **성능 로그**: 응답 시간, 처리량, 리소스 사용량
- **에러 로그**: 예외, 실패, 복구 시도

## 로그 보존 및 관리
- **보존 기간**: 애플리케이션 로그 30일, 시스템 로그 90일
- **로그 로테이션**: 파일 크기 기반(100MB) 및 시간 기반(일별)
- **압축**: 7일 이상 된 로그는 gzip 압축
- **아카이빙**: 30일 이상 된 로그는 별도 스토리지로 이동

# 메트릭 수집

## 핵심 성능 지표 (KPI)
- **처리 시간**: 전체 워크플로 실행 시간, 에이전트별 처리 시간
- **처리량**: 단위 시간당 처리된 PR 수, 동시 처리 가능한 요청 수
- **성공률**: 전체 성공률, 에이전트별 성공률, 에러 유형별 분류
- **리소스 사용량**: CPU, 메모리, 디스크 I/O, 네트워크 사용량

## 에이전트별 메트릭
- **DiffSummarizer**: 처리 시간, 하이라이트 생성 수, 리스크 식별 수
- **CodeReviewer**: 발견된 이슈 수, 심각도별 분류, 규칙 적용 수
- **DocsConsistencyChecker**: 불일치 발견 수, 패치 제안 생성 수
- **SchemaChangeAnalyst**: DDL 변경 감지 수, 브레이킹 체인지 수

## 툴별 메트릭
- **GitTool**: API 호출 수, 응답 시간, 캐시 히트율
- **LLMTool**: 토큰 사용량, API 호출 수, 응답 시간, 에러율
- **StaticAnalyzer**: 분석된 파일 수, 발견된 이슈 수, 처리 시간

# 트레이싱 및 상관관계

## 트레이스 ID 관리
- **고유 식별자**: 각 PR 리뷰 요청마다 UUID 기반 트레이스 ID 생성
- **상관관계 ID**: 관련된 모든 로그와 메트릭을 연결하는 식별자
- **전파**: 모든 에이전트와 툴 호출에서 트레이스 ID 전파
- **계층 구조**: 요청 → 워크플로 → 에이전트 → 툴 계층별 트레이스

## 분산 추적
- **스팬 생성**: 각 에이전트 실행과 툴 호출마다 스팬 생성
- **부모-자식 관계**: 워크플로와 에이전트 간의 실행 순서 추적
- **병렬 실행**: 동시 실행되는 에이전트들의 병렬 처리 추적
- **에러 전파**: 에러 발생 지점과 영향 범위 추적

# 성능 모니터링

## 성능 임계값 및 가드레일
- **전체 워크플로**: 최대 5분 (PRD NFR-1 기준)
- **에이전트별**: DiffSummarizer 1분, CodeReviewer 2분, DocsChecker 1분, SchemaAnalyzer 1.5분
- **툴별**: Git 작업 30초, LLM 호출 60초, 정적 분석 120초
- **메모리 사용량**: 최대 500MB, 초과 시 경고 및 정리

## 성능 병목 지점 식별
- **파일 크기**: 10k 라인 초과 시 샘플링 적용
- **LLM 호출**: 토큰 수 제한(16k), 필요 시 청크 분할
- **네트워크 지연**: 외부 API 호출 타임아웃 및 재시도 정책
- **디스크 I/O**: 대용량 파일 처리 시 스트리밍 방식 적용

## 성능 최적화 전략
- **병렬 처리**: 독립적인 에이전트는 동시 실행
- **캐싱**: 동일 입력에 대한 결과 재사용
- **지연 로딩**: 필요 시에만 리소스 로드
- **비동기 처리**: I/O 대기 시간이 긴 작업은 비동기 실행

# 비용 관리

## LLM API 비용 모니터링
- **토큰 사용량**: 입력/출력 토큰 수 실시간 추적
- **API 호출 비용**: 모델별, 토큰별 비용 계산 및 집계
- **사용량 제한**: 일일/월간 토큰 사용량 한도 설정
- **비용 알림**: 설정된 임계값 초과 시 즉시 알림

## 리소스 비용 최적화
- **컴퓨팅 리소스**: CPU/메모리 사용량에 따른 스케일링
- **스토리지 비용**: 로그 및 리포트 보존 기간 최적화
- **네트워크 비용**: 불필요한 외부 API 호출 최소화
- **캐시 효율성**: 캐시 히트율 향상으로 중복 작업 방지

# 알림 및 대시보드

## 알림 규칙
- **성능 임계값 초과**: 처리 시간이 설정값을 초과할 때
- **에러율 증가**: 에러율이 일정 임계값을 초과할 때
- **리소스 부족**: 메모리/CPU 사용량이 80% 초과할 때
- **비용 초과**: 일일/월간 비용이 설정값을 초과할 때

## 대시보드 구성
- **실시간 모니터링**: 현재 실행 중인 워크플로 상태
- **성능 대시보드**: 처리 시간, 처리량, 성공률 트렌드
- **리소스 대시보드**: CPU, 메모리, 디스크 사용량
- **비용 대시보드**: LLM API 사용량 및 비용 추이
- **에러 대시보드**: 에러 유형별 발생 빈도 및 추이

## 알림 채널
- **Slack**: 실시간 알림 및 팀 협업
- **이메일**: 일일/주간 요약 리포트
- **웹훅**: 외부 시스템 연동 및 자동화
- **SMS**: 긴급 상황 시 즉시 알림

# 모니터링 도구 및 통합

## 추천 모니터링 스택
- **로깅**: ELK Stack (Elasticsearch, Logstash, Kibana) 또는 Fluentd
- **메트릭**: Prometheus + Grafana 또는 DataDog
- **트레이싱**: Jaeger 또는 Zipkin
- **알림**: PagerDuty 또는 OpsGenie
- **대시보드**: Grafana 또는 DataDog

## 외부 서비스 통합
- **GitHub**: PR 상태 및 워크플로 실행 모니터링
- **Slack**: 실시간 알림 및 팀 협업
- **이메일**: 요약 리포트 및 중요 알림
- **웹훅**: CI/CD 파이프라인과의 연동

# 성능 테스트 및 벤치마크

## 성능 테스트 시나리오
- **소규모 PR**: 1k 라인 이하, 목표 처리 시간 1분 이내
- **중간 규모 PR**: 2k-5k 라인, 목표 처리 시간 2분 이내
- **대규모 PR**: 5k-10k 라인, 목표 처리 시간 5분 이내
- **초대규모 PR**: 10k 라인 이상, 샘플링 적용

## 벤치마크 기준
- **처리 시간**: 평균, 95퍼센타일, 99퍼센타일
- **처리량**: 초당 처리 가능한 PR 수
- **동시성**: 동시 처리 가능한 요청 수
- **리소스 효율성**: 처리당 CPU/메모리 사용량

## 성능 개선 사이클
- **측정**: 현재 성능 지표 수집 및 분석
- **분석**: 병목 지점 및 개선 기회 식별
- **개선**: 코드 최적화 및 설정 조정
- **검증**: 개선 효과 측정 및 검증
- **반복**: 지속적인 성능 개선 사이클

# 운영 및 유지보수

## 정기 성능 검토
- **일일 검토**: 주요 성능 지표 및 알림 현황
- **주간 검토**: 성능 트렌드 및 개선 사항 분석
- **월간 검토**: 전체 성능 현황 및 장기 개선 계획
- **분기별 검토**: 아키텍처 수준의 성능 최적화 검토

## 성능 이슈 대응
- **즉시 대응**: 심각한 성능 저하 시 즉시 조치
- **근본 원인 분석**: 성능 이슈의 원인 분석 및 해결
- **예방 조치**: 유사한 이슈 재발 방지를 위한 개선
- **문서화**: 이슈 대응 과정 및 교훈 문서화

## 용량 계획
- **현재 용량**: 현재 시스템의 최대 처리 능력
- **예상 부하**: 향후 3개월, 6개월, 1년간의 예상 부하
- **확장 계획**: 부하 증가에 따른 확장 방안
- **비용 예측**: 확장에 따른 예상 비용 및 ROI 분석

# 성능 최적화 가이드라인

## 코드 레벨 최적화
- **알고리즘 최적화**: 시간/공간 복잡도 개선
- **메모리 관리**: 불필요한 객체 생성 방지, 가비지 컬렉션 최적화
- **비동기 처리**: I/O 대기 시간이 긴 작업의 비동기 처리
- **캐싱 전략**: 동일 계산 결과 재사용

## 시스템 레벨 최적화
- **리소스 할당**: CPU/메모리 적절한 할당 및 모니터링
- **네트워크 최적화**: 연결 풀링, 압축, 배치 처리
- **데이터베이스 최적화**: 쿼리 최적화, 인덱스 관리
- **로드 밸런싱**: 부하 분산 및 장애 대응

## 운영 레벨 최적화
- **자동 스케일링**: 부하에 따른 자동 리소스 조정
- **백그라운드 작업**: 비동기 처리 및 배치 작업
- **모니터링 및 알림**: 실시간 성능 모니터링 및 임계값 알림
- **정기 점검**: 성능 지표 정기 분석 및 개선 계획 수립

이러한 관찰성 및 성능 관리 규칙을 통해 PRD의 성능 요구사항을 충족하고, 안정적이고 효율적인 시스템을 운영할 수 있습니다.

- LLM 호출 단가/토큰 사용량 수집 → 리포트에 표기
- 대용량 diff는 파일 단위 샘플링 후 근거를 유지(라인 범위 보존)
- 타임아웃: 툴 30s 기본, LLM 60s, 전체 파이프라인 5분
